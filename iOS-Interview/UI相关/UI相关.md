##  UI相关

1、UITableView为什么要使用重用机制？<br/>
重用机制：系统会创建当前屏幕cell数+1个cell，UITableView向上滑动时，当第一个cell完全滑出屏幕后，就会被加入到重用池中，接下来继续向上滑动时，当一个新的cell出现时，就会根据指定的identifier标示符，从重用池中取出一个可重用的cell。<br/>
如果不用重用机制会重复初始化原来已初始化过的cell，使用重用机制可以减少内存消耗，从而提高滑动流畅性，避免出现一些网络因素而造成的卡顿现象。<br/>

2、UITableView有一个数据源datasource，用户对datasource进行删除某一个元素的操作，与此同时向服务器请求数据，请求后的数据会对datasource进行赋值操作。用户删除操作是在主线程，请求数据并赋值操作是在子线程，两个线程会同时对datasource进行操作，从而产生数据源同步问题，如何避免？<br/>
方案一：当用户进行删除操作后，将删除的元素进行拷贝记录，当请求数据时，用拷贝的元素与请求数据进行对比，然后进行同步的删除操作，最后再对datasource进行赋值，这样就解决了数据源同步问题（数据源数据较大时，会有拷贝带来的性能损耗）。<br/>
方案二：将删除操作与数据源请求操作加入串行队列，删除操作需要等待网络请求和数据解析结束后才能进行（请求数据时间过长时，会对删除操作有延时）。<br/>

3、UIView和CALayer的关系？<br/>
UIView继承自UIResponder，为CALayer提供内容，负责处理触摸等事件，并参与响应链。CALayer继承自NSObject，负责显示内容contents。<br/>

4、事件传递与视图响应链是怎样的？<br/>
1）开始遍历。<br/>
2）视图没有隐藏&视图存在点击事件&透明度不为0，继续进行，否则返回nil。<br/>
3）判断点击视图是否在当前视图内，视图存在，继续下一级进行，否则返回nil。<br/>
4）遍历视图（最后添加的视图优先遍历），通过响应视图hitTest方法，判断视图是否存在，如果不存在，继续遍历，直到找到最后的响应视图。<br/>
5）遍历子视图（最后添加的视图优先遍历），如果视图不存在，结果为上一层视图。<br/>
如果事件一直传递到UIAppliction还是没处理，那就会忽略掉。<br/>

5、图像显示原理是什么？<br/>
1）CPU、GPU两个硬件都是通过总线连接起来的。<br/>
2）在CPU中输出的结果是一个位图。（UI布局、文本计算、绘制、解码、提交位图）<br/>
3）通过总线，在合适的时机上传给GPU。<br/>
4）GPU拿到这个位图后，会做一些图层的渲染、纹理的合成，最终把结果放到帧缓冲器当中(Frame Buffer)。<br/>
5）随后视频控制器会按照vsync信号逐行读取帧缓冲区的数据，最后显示到我们的显示器上。<br/>

6、UI卡顿掉帧的原因是什么？<br/>
iOS设备的硬件时钟会发出Vsync(垂直同步信号)，然后App的CPU 会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个 VSync到来时将 缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GPU共同决定的。一般来说，页面滑动流畅性是60FPS，也就是1s有60帧更新时人眼看到的就是流畅的，即每隔 16.7ms就要产生一帧画面，而如果CPU和GPU加起来的处理时间超过了16.7ms，就会造成掉帧甚至卡顿。

7、如何优化滑动？<br/>
从CPU角度：<br/>
1）对象创建、调整、销毁可以放到子线程中，节省CPU的时间。<br/>
2）预排版(布局,文本计算)放到子线程中，主线程响应用户的交互。<br/>
3）预渲染(文本等异步绘制、图片编解码等)放到子线程中。<br/>
从GPU角度：<br/>
减轻视图层级的复杂性，减轻GPU的压力。<br/>
主要考虑以下问题：是否受到CPU或者GPU的限制？是否有不必要的CPU渲染？是否有太多的离屏渲染操作？是否有太多的图层混合操作？是否有奇怪的图片格式或者尺寸？ 是否涉及到昂贵的view或者效果？view的层次结构是否合理？<br/>

8、UI绘制原理是什么？<br/>
1）[UIView setNeedsDisPlay] <br/>
2）[view.layer setNeedsDisplay] <br/>
3）[CALayer display] <br/>
4）是否响应view.layer.delegate的displayLayer方法，如果不响应displayLayer方法，就会进入到系统绘制流程当中；如果响应displayLayer方法，就会开启异步绘制。<br/>
系统绘制：<br/>
1）判断是否使用layer的代理方法。<br/>
2）如果使用，就调用系统的drawLayer方法，通过UIView的drawRect进行视图绘制。<br/>
3）如果不使用，调用drawinContext方法。<br/>
4）最终是CALayer上传位图到GPU。<br/>
异步绘制：响应displayLayer，代理负责生成对应的位图，位图作为layer.contents属性的值。<br/>
1）在主队列调用setNeedsDisplay。<br/>
2）在当前runloop将要结束的时候，调用display方法，代理实现displayLayer函数，调用displayLayer方法。<br/>
3）通过子线程切换，进行位图绘制。<br/>
4）子线程中三个方法，CGBitmapContextCreate()创建位图上下文，通过CoreGraphic API进行位图绘制工作，通过位图上下文生成图片。<br/>
5）回到主队列当中，提交位图，设置CALayer的content属性，完成CALayer的异步绘制。<br/>

9、谈谈对离屏渲染的理解？<br/>
On-Screen Rendering：当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br/>
Off-Screen Rendering：离屏渲染，分为CPU离屏渲染和GPU离屏渲染两种形式。GPU离屏渲染指的是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作。<br/>
触发离屏渲染的操作：<br/>
1）圆角(与maskToBounds一起使用时)。<br/>
2）图层蒙版。<br/>
3）阴影(shadows)。<br/>
4）光栅化(shouldRasterize)。<br/>
GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到离屏渲染的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响。另外由于离屏渲染会增加GPU的工作量，可能会导致CPU+GPU的处理时间超出16.7ms，导致掉帧卡顿。所以可以的话应尽量 减少离屏渲染的图层。


### 补充
设置光栅化shouldRasterize =YES
在其他属性触发离屏渲染的同时会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度。<br/>
例如在滚动tableView时，每次都执行圆角设置，肯定会阻塞UI，设置光栅化就可以使滑动更加流畅。实现圆角本身就是在做颜色混合，如果每次页面出来时都blending，消耗太大，这时如果设置了光栅化，下次就只是简单的从渲染引擎的cache里读取那张bitmap，可以大大节约系统资源。<br/>
光栅化本身会导致离屏渲染，影响图像性能，那么光栅化是否有助于优化性能，就取决于光栅化创建的位图缓存是否被有效复用，而减少渲染的频度。可以使用Instruments进行检测：当使用光栅化时，可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。如果光栅化的图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。<br/>
对于经常变动的内容就不要开启光栅化了，否则会造成性能的浪费。
