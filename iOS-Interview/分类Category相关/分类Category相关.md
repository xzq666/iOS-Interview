##  分类Category相关

1、分类的作用？<br/>
声明私有方法，分解体积大的类文件，把framework的私有方法公开。<br/>

2、分类有哪些特点？<br/>
运行时决议，可以为系统类添加分类 。在运行时将Category中的实例方法列表、协议列表、属性列表添加到主类中后，然后会递归调用所有类的load方法，这一切都是在main函数之前执行的。<br/>

3、分类可以添加哪些内容？<br/>
实例方法，类方法，协议，属性（通过关联对象方式添加成员变量，可以为其添加getter和setter方法）。<br/>

4、如果工程里有两个分类A和B，两个分类中有一个同名的方法，哪个方法最终生效？<br/>
取决于分类的编译顺序，最后编译的那个分类的同名方法最终生效，而之前的都会被覆盖掉。这里并不是真正的覆盖，因为其方法仍然存在，只是访问不到。在动态添加类的方法的时候先是倒序遍历方法，最后编译的分类的方法会放在靠前，然后添加到原类方法的前面（先将元类方法move到方法列表后面，再将分类方法copy到方法列表前面），所以访问的时候最后编译的分类的方法就会先被访问到，同理如果声明了一个和原类方法同名的方法，也会覆盖掉原类的方法。<br/>

5、如果声明了两个同名的分类会怎样？<br/>
会报错，所以第三方的分类一般都带有命名前缀防止出现同名分类。<br/>

6、分类能添加成员变量吗？介绍一下关联对象？<br/>
不能，但可以通过关联对象来模拟实现成员变量。<br/>
关联对象的实质是关联内容，并不是存储在被关联对象本身内存中，所有对象的关联内容都放在同一个全局容器哈希表(AssociationsHashMap)中，由AssociationsManager统一管理。设置关联对象为nil，相当于移除关联对象，例如objc_setAssociatedObject(self, “key”, nil, OBJC_ASSOCIATION_ASSIGN);会将“key”关联移除。

7、介绍一下扩展Extension？与Category有什么区别？<br/>
扩展一般用于声明私有属性，声明方法（没什么意义），声明私有成员变量。扩展在编译时决议，只能以声明的形式存在，多数情况下寄生在宿主类的.m文件中，不能为系统类添加扩展。扩展在编译的时候，数据就已经包含在类信息中了；而Category是在运行时才将数据合并到类信息中的。<br/>

8、Category的实现原理是什么？<br/>
Category编译之后的底层结构是struct category_t，里面存储着Category的对象方法、类方法、属性、协议信息。
在程序运行时，Runtime会将Category的数据合并到类信息中（类对象、元类对象）。<br/>

9、Category的加载处理过程是怎样的？<br/>
1）通过Runtime加载某个类的所有Category数据。<br/>
2）把所有Category的方法、属性、协议数据合并到一个大数组中（参与编译顺序靠后的Category数据会在数组的前面）。<br/>
3、将合并后的分类数据（方法、属性、协议）插入到类原来数据的前面。<br/>

10、Category中有load方法吗？load方法是什么时候调用的？load方法能继承吗？<br/>
Category中有load方法。<br/>
load方法会在Runtime加载类、分类时就调用一次。先调用类的load（按照编译先后顺序调用，调用子类的load方法之前会先调用父类的load），再调用分类的load（按照编译先后顺序调用）。<br/>
可以继承，但一般情况下我们不会主动去调用，都是让系统自动调用。<br/>

11、load、initialize方法的区别是什么？它们在Category中的调用顺序？出现继承时它们之间的调用过程？<br/>
load是根据函数地址直接调用，不会覆盖，而initialize是通过objc_msgSend调用，会覆盖；load是Runtime加载类、分类的时候调用，而initialize是类第一次接收到消息时调用。<br/>
load先按照编译顺序调用类的load，调用子类的load之前会调用父类的load，然后再按照编译顺序调用分类的load；initialize在类第一次接收到消息时通过objc_msgSend调用，先调用父类的initialize再调用子类的initialize，若分类实现了initialize就覆盖类原来的initialize调用，若子类没有实现initialize，会调用父类的initialize。<br/>
出现继承时load是先调用父类的再调用子类的，而initialize是子类不存在（包括子类与子类的分类）再调用父类的（包括父类与父类的分类）。<br/>
