##  多线程相关

1、什么是进程？什么是线程？进程与线程有什么关系？<br/>
进程是一个具有一定独立功能的程序，它是操作系统分配资源的基本单元。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源。<br/>
线程是程序执行流的最小单元，是进程中的一个实体。一个进程要想执行任务，必须至少有一条线程。应用程序启动的时候，系统会默认开启一条线程，也就是主线程。<br/>
线程是进程的执行单元，进程的所有任务都在线程中执行。线程是 CPU 分配资源和调度的最小单位，一个程序可以对应多个进程(多进程)，一个进程中可有多个线程，但至少要有一条线程。同一个进程内的线程共享进程资源。<br/>

2、什么是多线程？<br/>
多线程就是多个线程并发执行的技术，其目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。事实上，同一时间内单核的CPU只能执行一个线程，此时多线程只是 CPU 快速的在多个线程之间进行切换（调度），以造成多个线程同时执行的假象。只有在多核 CPU 中才可以坐到真正同时处理多个线程。<br/>

3、多线程有哪些优点与缺点？<br/>
优点：<br/>
1）适当提高程序的执行效率；<br/>
2）适当提高资源利用率（CPU、内存利用率）。<br/>
缺点：<br/>
1）开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能；<br/>
2）在单核 CPU 下，线程越多，CPU 在调度线程上的开销就越大；<br/>
3）可能存在线程之间的通信、多线程的数据共享等问题，使程序设计更加复杂。<br/>

4、多线程的并行和并发有什么区别？<br/>
并行：充分利用计算机的多核，在多个线程上同时进行。<br/>
并发：单核 CPU 在多个线程之间快速切换，使多个线程看起来在同时执行一样，但实际上同一时刻只有一条线程在进行。<br/>

5、iOS中有哪几种实现多线程的方案？各自有什么特点？<br/>
1）pthread<br/>
基于C语言的一套通用的多线程API，适用于Unix、Linux、Windows等系统（跨平台、可移植），但是使用难度大，线程生命周期由程序员管理，开发中几乎不用。<br/>
2）NSThread<br/>
基于Objective-C，面向对象，简单易用，可直接操作线程对象。线程生命周期由程序员管理，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。开发中偶尔使用。<br/>
3）GCD<br/>
基于C语言，旨在替代NSThread等线程技术，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。开发中经常使用。<br/>
4）NSOperation<br/>
基于Objective-C，是对GCD的封装，比GCD多了一些更简单实用的功能，更加面向对象。自动管理线程生命周期。开发中经常使用。<br/>

6、多个网络请求完成后如何执行下一步？<br/>
1）方案一：使用GCD的diapatch_group_t<br/>
创建一个dispatch_group_t，每次网络请求前先dispatch_group_enter，请求回调后再dispatch_group_leave，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。当所有enter的block都leave后，会执行dispatch_group_notify的block。<br/>

    // 创建group
    dispatch_group_t group = dispatch_group_create();
    for (int i=0; i<10; i++) {
        // 每个网络请求前先enter
        dispatch_group_enter(group);
        NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            // 每个网络请求结束后调用leave
            dispatch_group_leave(group);
        }];
        [task resume];
    }
    // 当所有enter都leave后，调用dispatch_group_notify
    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{
        NSLog(@"end");
    });
<br/>
2）方案二：使用GCD的信号量dispatch_semaphare_t<br/>
dispatch_semaphare_t信号量为基于计数器的一种多线程同步机制。如果信号量的值>0，就让信号量的值减1，并继续往下执行代码；如果信号量的值<=0，就休眠等待，直到信号量的值>0，才继续往下执行代码。dispatch_semaphore_create(0)创建信号量为0的semaphore，此时当前线程休眠等待，等多个网络请求都完成后，使用dispatch_semaphore_signal(semaphore)为计数+1，dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)为设置等待时间，设置成一直等待。当计数大于1时，它就会将计数-1并继续往下执行代码。

    // 创建信号量 计数为0
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    for (int i=0; i<10; i++) {
        NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            count++;
            if (count==10) {
                // 所有网络请求结束调用dispatch_semaphore_signal，让计数+1，使信号量大于0
                dispatch_semaphore_signal(semaphore);
                count = 0;
            }
        }];
        [task resume];
    }
    // 计数为0时当前线程会休眠等待，直到所有网络请求都完成后信号量为1时才会计数-1并往下执行
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@"end");
    });
<br/>

7、多个网络请求顺序执行后如何执行下一步？<br/>
使用信号量，每一次遍历，都让其dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)，这个时候线程会等待，阻塞当前线程，直到dispatch_semaphore_signal(semaphore)调用之后才会放开。

    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    for (int i=0; i<10; i++) {
        NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            // 每次网络请求结束后调用，让计数+1，使信号量大于0
            dispatch_semaphore_signal(semaphore);
        }];
        [task resume];
        // 当前网络请求结束前都休眠等待，完成一个才放开继续下一个
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
    }
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@"end");
    });
<br/>

8、如何理解多线程中的死锁？<br/>
死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，可以理解为程序卡住。产生死锁的必要条件有四个：<br/>
1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。<br/>
2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。<br/>
3）不可剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。<br/>
4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。<br/>
iOS中最常见的死锁就是使用sync函数往当前串行队列中添加任务，本质是队列阻塞。<br/>

9、介绍一下GCD的执行原理？<br/>
GCD有一个底层线程池，存放着一个个可以重用的的线程，当一段时间后若某个线程没有被调用的话，这个线程就会被销毁。开多少条线程是由底层线程池决定的（线程建议控制在3~5条），底层线程池是系统自动维护的， 程序员只需要关心向队列中添加任务，队列调度即可。<br/>
若队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。<br/>
若队列中存放的是异步任务，当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。<br/>
这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，从而节约系统的开销，提高了效率。在iOS7的时候，使用GCD系统通常只能开5~8条线程，iOS8以后，系统可以开启很多条线程，但在实际开发应用中，建议开启线程条数一般为3~5条。<br/>
